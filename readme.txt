Функція жадібного алгоритму

Використані монети для суми 113: {50: 2, 10: 1, 2: 1, 1: 1}
Час виконання find_coins_greedy113 - 7.800001185387373e-06 секунд
Використані монети для суми 1557 - {50: 31, 5: 1, 2: 1}
Час виконання find_coins_greedy для суми 1557 - 6.800051778554916e-06 секунд
Використані монети для суми 55557 - {50: 1111, 5: 1, 2: 1}
Час виконання find_coins_greedy для суми 55557 - 9.399955160915852e-06 секунд

Функція динамічного програмування

Використані монети для суми 113 - {1: 1, 2: 1, 10: 1, 50: 2}
Час виконання find_min_coins для суми 113 - 0.0011405000113882124 секунд
Використані монети для суми 1557 - {2: 1, 5: 1, 50: 31}
Час виконання find_min_coins для суми 1557 - 0.01001270004780963 секунд
Використані монети для суми 55557 - {2: 1, 5: 1, 50: 1111}
Час виконання find_min_coins для суми 55557 - 2.487595899961889 секунд


З цих даних можна побачити, що жадібний алгоритм працює швидше, ніж алгоритм динамічного програмування, для невеликих і середніх сум грошей (наприклад, 1557), оскільки йому не потрібно розглядати всі можливі комбінації монет. Однак, зі збільшенням суми (наприклад, 55557) або при використанні інших наборів монет, алгоритм динамічного програмування може виявитися більш ефективним, оскільки забезпечує оптимальний результат і не пропускає жодної кращої комбінації. Отже, вибір між цими двома алгоритмами залежить від конкретної задачі, кількості номіналів монет і розміру суми, яку потрібно обчислити.