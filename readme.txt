Функція жадібного алгоритму

Використані монети для суми 113 - {50: 2, 10: 1, 2: 1, 1: 1}
Час виконання find_coins_greedy113 - 9.000010322779417e-06 секунд
Використані монети для суми 1557 - {50: 31, 5: 1, 2: 1}
Час виконання find_coins_greedy для суми 1557 - 6.699992809444666e-06 секунд
Використані монети для суми 55557 - {50: 1111, 5: 1, 2: 1}
Час виконання find_coins_greedy для суми 55557 - 6.89999433234334e-06 секунд

Функція динамічного програмування

Використані монети для суми 113 - {1: 1, 2: 1, 10: 1, 50: 2}
Час виконання find_min_coins для суми 113 - 0.0006959000020287931 секунд
Використані монети для суми 1557 - {2: 1, 5: 1, 50: 31}
Час виконання find_min_coins для суми 1557 - 0.012583100004121661 секунд
Використані монети для суми 55557 - {2: 1, 5: 1, 50: 1111}
Час виконання find_min_coins для суми 55557 - 2.898465199978091 секунд


З цих даних можна побачити, що жадібний алгоритм працює швидше, ніж алгоритм динамічного програмування, 
для невеликих і середніх сум грошей (наприклад, 1557), оскільки йому не потрібно розглядати всі можливі 
комбінації монет. Однак, зі збільшенням суми (наприклад, 55557) або при використанні інших наборів монет, 
алгоритм динамічного програмування може виявитися більш ефективним, оскільки забезпечує оптимальний 
результат і не пропускає жодної кращої комбінації. Отже, вибір між цими двома алгоритмами залежить від
конкретної задачі, кількості номіналів монет і розміру суми, яку потрібно обчислити.